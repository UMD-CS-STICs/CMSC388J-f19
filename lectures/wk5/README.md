# Week 5
### Forms & CSRF

The slides for this week are linked on Piazza. 

The code in this directory follows along with these lecture notes. If you have any
questions or fixes in these notes, please let us know.

To run all of the code, make sure to `pip install Flask flask-sqlalchemy Flask-WTF` if
you haven't already.

Optionally, `pip install python-dotenv` to automatically set environment variables
for your flask apps (as detailed in the week 2 notes).

### CSRF attacks

We won't go over an example of a CSRF attack, but we'll go over the theory and how
an attack like it may be pulled off, and how we would prevent it, theoretically.

CSRF stands for "**C**ross-**S**ite **R**equest **F**orgery". If you are authenticated
with a certain website, like a social media website, a session and IP address information 
may be stored in a cookie in your browser and all of these credentials would be sent to the social
media website with any request. 

**Aside:** A *cookie* is a packet of information that is sent to your browser containing
some info about the current user or website visit session. It is sent from the browser
to the web server along with every request so that the server can send back appropriate data.

If the user is authenticated with our social media website, then the server cannot
tell the difference between the legitimate forms on your website and the forged
forms on an attacker's website, because the same cookie with authentication will be sent. 
We protect against CSRF attacks by including this extra token that isn't accessible to the 
attacker, and that can't be used by the attacker if they create a forged form.

For example, we might have a route exposed on our website where the user can send a
`POST` request in order to change their password, maybe 
`https://website.com/account/change_password`. The user would have to be authenticated to
change their password. An attacker could create a webpage that will send a `POST` 
request to this website route with some JS. If an authenticated user visited the
malicious site (and we didn't have CSRF protection), then the attacker could
change your password to whatever they wanted.

The most popular and effective ways to prevent CSRF attacks is to use a secure, random token
that satisfies three properties:
- Unique per session
- Large random value
- Generated by a cryptographically secure pseudo-random number generator (CSPRNG)

We'll use `Flask-WTF` to protect our applications from CSRF attacks.

### Sessions

When you log into your bank account on your bank's website, or try to use a website
for a service that is supposed to be highly secure, you've probably seen a message
along the lines of `"Your session is expiring in 10 minutes"` or
`"Your session has expired"`. 

![Expired session][expired]

Sessions keep track of information specific to the application user between
requests. Perhaps they go from a "Change Password" screen to a "Edit Profile" screen;
we still want to keep track of which user is actually making all of these requests.
We can use the `session` object of `flask` to read and modify information in the current
session.

To use a session, we have to set a configuration option known as `'SECRET_KEY'`. This should
be a randomly generated string that we use to sign off on cookies. The reason we want to
sign off on our cookie with a secret key is so that the browser/user cannot modify 
the identifying information that may be stored in the cookie; they should only be able
to read the data. This prevents users from pretending to be other users by
changing cookie contents.

To generate a secret key for our application, and we only want to generate one for
our application, we can use the `os` module of the Python standard library.
Here's an example of how to generate a secret key:

```python
import os

print(os.urandom(16))
```

After running this, I got a key of 
b'z\x8b\x7fs\xb2\xfa\xeb\x1a\xe6\xa8\xcd\x81\xf2Qq\xdb'`. 
The `b` in front of the string indicates that it's a string of bytes. 
The secret key will be different for you, and it may appear to be a different length, too. 
This is fine, the `32` in the argument to `os.urandom()` indicates that we'll
get back a string of 32 random bytes. 

When creating your application, you can set the secret key configuration option using:

`__init__.py`:
```python
from flask import Flask, session

app = Flask(__name__)
app.config['SECRET_KEY'] = b'z\x8b\x7fs\xb2\xfa\xeb\x1a\xe6\xa8\xcd\x81\xf2Qq\xdb'
```

And now we can use the `session` object! `session` is a `dict`, so we can set
values and check if certain values exist in our `session` during the lifetime of the web
application.

This section is necessary for securing your forms in the next section.

### Flask-WTF

`Flask-WTForms` is an extension for `flask` that allows us to easily use `WTForms`.
`WTForms` is a framework that allows you to generate an HTML form and then customize
the look and feel of your user interface in the template. `WTForms` helps you separate
the business logic from the presentation.

All of our forms will be subclasses of `FlaskForm`. `FlaskForm` comes from `flask_wtf`, and
by default, they come with CSRF protection. To create the CSRF token, a secret key
must be set like we did in the Sessions section above.

To start off, we can make a sample form:

`forms.py`:
```python
from flask_wtf import FlaskForm
from wtforms import StringField, IntegerField
from wtforms.validators import DataRequired, NumberRange, Length

class WelcomeForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired(), Length(min=4, max=30)])
    location = StringField('Location', validators=[DataRequired(), Length(min=3, max=50)])
    age = IntegerField('Age', validators=[DataRequired(), NumberRange(min=1, max=140, message='Must be between 1 and 140')])
```

We import the `FlaskForm` class, then create a subclass called `WelcomeForm`.
We add two text fields for entering name and location for the user, and we
indicate that the field is required by using an instance of the `DataRequired()`
class. We also add a field for entering an integer age, and require that the age 
be between 1 and 140.

We can render this form in our template by creating an object of type `WelcomeForm`
and then passing it in as a parameter to the `render_template()` function.

`routes.py`:
```python
from flask_app import app
from flask import render_template, redirect
from flask_app.forms import *

@app.route('/', methods=['GET', 'POST'])
def index():
    form = WelcomeForm()
    if form.validate_on_submit():
        return redirect('/')
    return render_template('index.html', title='Front page', form=form)

@app.route('/about')
def about():
    return render_template('about.html', title='About')
```

`__init__.py`:
```python
from flask import Flask, session
from flask_wtf.csrf import CSRFProtect

app = Flask(__name__)
app.config['SECRET_KEY'] = b'z\x8b\x7fs\xb2\xfa\xeb\x1a\xe6\xa8\xcd\x81\xf2Qq\xdb'

from flask_app import routes
```

`index.html`:
```html
{% extends "base.html" %}
{% block content %}
<h1>Welcome to the website!</h1>
<form action="/" method="post">
    {{ form.csrf_token }}
    {{ form.name.label }}: {{ form.name(size=40) }} <br>
    {{ form.location.label }} {{ form.location(size=60) }} <br>
    <input type="submit" value="Enter">
</form>
{% endblock %}
```

The `{{ form.csrf_token }}` is a hidden input field to our HTML form. It is rendered
by the form automatically for the current session, and is based off of the `SECRET_KEY`
that we created earlier.

And if we run the app now, we should be able to submit the form, although nothing changes.
We want to greet the user that just entered in their info, so we'll alter
`index()` in `routes.py` slightly. We can use the `session` object we discussed
earlier to store values from our form.

`routes.py`:
```python
@app.route('/', methods=['GET', 'POST'])
def index():
    form = WelcomeForm()
    if request.method == 'POST':
        if form.validate():
            session['name'] = form.name.data
            session['location'] = form.location.data
            session['age'] = form.age.data
            session.modified = True
        else:
            print('validation failed')
        
        return redirect(request.path)

    message = None
    if 'name' in session:
        message = 'Welcome %s of %s' % (session['name'], session['location'])
    
    return render_template('index.html', title='Front page', message=message, form=form)
```

First, we check if we received a `POST` request. If so, and the form data is valid,
we store the info from the form into our `session` object. We also create
a custom message that will greet our user with the newly entered name and location.

This is about as complicated as `WTForms` gets (unless you're trying to create
custom validators or fields). There is a list of validators 
[here](https://wtforms.readthedocs.io/en/stable/validators.html) and
a list of fields [here](https://wtforms.readthedocs.io/en/stable/fields.html#basic-fields)
for your reference.

### More SQLAlchemy

We'll go over another feature of `SQLAlchemy` that allows us to define relationships
between our tables. Recall that we created a `User` table in our database this way:

```python
class User(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    bio = db.Column(db.String(500), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    location = db.Column(db.String(100), nullable=False)

    def __repr__(self):
        return 'User: %s' % self.name
```

We specified the name and type of each column in our database, and created a 
representation for a record in `User`. We might have a need to keep track of
comments on our website, in which case we might create a table called `Comments`.
A comment has some text, a date and time for when it was created, and
the author of the comment. 

The author of any comment is also a user, and so would be recorded in the `User`
table. We could just use a string to keep track of a user's name and then search
the `Uses` table for that specific user, and get information, or we can define a
relationship between the two tables. Since one user can have multiple comments on a website,
we'll be defining a one-to-many relationship between database tables here.

```python
from flask_app import db
from datetime import datetime

class User(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    bio = db.Column(db.String(500), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    location = db.Column(db.String(100), nullable=False)
    comments = db.relationship('Comment', backref='user', lazy=True)

    def __repr__(self):
        return 'User: %s' % self.name

class Comment(db.Model):

    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.String(300), nullable=False)
    date = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    writer_email = db.Column(db.Integer, db.ForeignKey('user.email'), nullable=False)

    def __repr__(self):
        return 'Comment id: %s by User with email: %s' % (self.id, self.writer_email)
```

In `Users`, we declared a new property called `user` for the `Comment` class, so
the `user` for a certain comment can be accessed with `comment.user`. The keyword
argument `backref` creates this new property. The first argument specifies which `Model`
class to add the property to. We identify `Address` by a string because
it hasn't been created yet in the file.

We also specify `lazy` to be `True` so that data
is loaded only when requested, not when the parent is also called for data.

In `Comment`, we create a new column of integers whose value is the `id` of a `user`.
This allows us to associate every record in the `Comment` table with a `user`.


How do we use these models? We'll try it out in the Python REPL:

```python
>>> from flask_app import *
>>>
>>> db.create_all()
>>>
>>> harry = Users(name='Harry Potter', bio='I am a wizard, Voldemort tried to kill me!', email='harry@hogw.edu', location='Scotland')
>>> db.session.add(harry)
>>> db.session.commit()
>>>
>>> Users.query.all()
[User: Harry Potter]
>>>
>>> comment = Comment(text='First time on here, great site!', user=harry)
>>>
>>> db.session.add(comment)
>>> db.session.commit()
>>>
>>> Comment.query.all()
[Comment id: 1 by User with email: harry@hogw.edu]
```

When trying to retrieve values from our database, we call get the attribute
`query` from a `Model` subclass, and then we can apply filters and then call
`all()` or `first()` on the query to retrieve values.

Now let's see how to easily add multiple values and more examples of how to
query records:

```python
>>> yashas = User(name='Yashas', bio="I'm an Indian CS+Math student", email='yashloke@umd.edu', location='USA')
>>> kenton = User(name='Kenton', bio="I'm Kenton, a CS student", email='kdubbs0@umd.edu', location='USA')
>>> armin = User(name='Armin', bio="The creator of Werkzeug and Flask", email='armin.ronacher@active-4.com', location='Austria')
>>> knuth = User(name='Donald', bio="I wrote the classic algorithms series of books, the Art of Computer Programming", email='N/A', location='California')
>>>
>>> db.session.add_all([yashas, kenton, armin, knuth])
>>> db.session.commit()
>>>
>>> User.query.filter_by(location='USA').all()
[User: Yashas, User: Kenton]
>>> User.query.filter_by(location='USA').first()
User: Yashas
>>> User.query.first()
User: Harry Potter
>>> User.query.filter_by(location='Canada').all()
[]
```

We create 4 instances of the `User` class and fill out all of the necessary
properties. Since we specified that an email cannot be `null` in the class definition,
we put a placeholder "N/A" string for `knuth`'s email. Then we add all of the instances
of `User` to our database session, and commit the changes. 

We can query our `User` table by the location of each user, and then all of the results, 
or just the first result as shown above. You can use any property of your `Model` in 
order to filter results from the database query. 

We defined a relationship between `User` and `Comment` using the `db.relationship()`
in `models.py`. We can check if this relationship actually exists in the database, and
how we can use it:

```python
>>> c = Comment.query.first()
>>> c
Comment id: 1 by User with email: harry@hogw.edu
>>> c.writer_email
'harry@hogw.edu'
>>> c.user.id
1
>>> c.user.comments
[Comment id: 1 by User with email: harry@hogw.edu]
```

And finally, to delete any record from a database, we can just use the 
`delete()` method instead of the `add()` method.

```python
>>> User.query.all()
[User: Harry Potter, User: Yashas, User: Kenton, User: Armin, User: Donald]
>>> u = User.query.filter_by(name='Yashas').first()
>>>
>>> db.session.delete(u)
>>> db.session.commit()
>>>
>>> User.query.all()
[User: Harry Potter, User: Kenton, User: Armin, User: Donald]
```

We grabbed the user with name `'Yashas'` by using the `filter_by().first()` sequence of calls, 
then we just delete him from our database and commit the changes.

### Conclusion

In this lecture we showed how to work with `Flask-WTF`, what sessions are
and how to use them, and a little bit more about `SQLAlchemy`. Next week,
we'll get more into user management and how to secure your website for logins.


[expired]: ./images/expired.jpeg "Expired Session image"